#include <avr/io.h>
#include "st7735.h"
#include <avr/pgmspace.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define xSize 128
#define ySize 128
#define xMax 127
#define yMax 127



#define MOSI 5
#define SCK 7
#define SS 0 //SS for pin1, can add device later
#define DC 1 //A0 pin for TFT
#define RESET 7 //Reset pin on TFT
#define LED 0// LED pin

uint8_t curX,curY; // current x & y cursor position

const uint8_t FONT_CHARS[96][5] PROGMEM = {

	{ 0x00, 0x00, 0x00, 0x00, 0x00 }, // (space)
	{ 0x00, 0x00, 0x5F, 0x00, 0x00 }, // !
	{ 0x00, 0x07, 0x00, 0x07, 0x00 }, // "
	{ 0x14, 0x7F, 0x14, 0x7F, 0x14 }, // #
	{ 0x24, 0x2A, 0x7F, 0x2A, 0x12 }, // $
	{ 0x23, 0x13, 0x08, 0x64, 0x62 }, // %
	{ 0x36, 0x49, 0x55, 0x22, 0x50 }, // &
	{ 0x00, 0x05, 0x03, 0x00, 0x00 }, // '
	{ 0x00, 0x1C, 0x22, 0x41, 0x00 }, // (
	{ 0x00, 0x41, 0x22, 0x1C, 0x00 }, // )
	{ 0x08, 0x2A, 0x1C, 0x2A, 0x08 }, // *
	{ 0x08, 0x08, 0x3E, 0x08, 0x08 }, // +
	{ 0x00, 0x50, 0x30, 0x00, 0x00 }, // ,
	{ 0x08, 0x08, 0x08, 0x08, 0x08 }, // -
	{ 0x00, 0x60, 0x60, 0x00, 0x00 }, // .
	{ 0x20, 0x10, 0x08, 0x04, 0x02 }, // /
	{ 0x3E, 0x51, 0x49, 0x45, 0x3E }, // 0
	{ 0x00, 0x42, 0x7F, 0x40, 0x00 }, // 1
	{ 0x42, 0x61, 0x51, 0x49, 0x46 }, // 2
	{ 0x21, 0x41, 0x45, 0x4B, 0x31 }, // 3
	{ 0x18, 0x14, 0x12, 0x7F, 0x10 }, // 4
	{ 0x27, 0x45, 0x45, 0x45, 0x39 }, // 5
	{ 0x3C, 0x4A, 0x49, 0x49, 0x30 }, // 6
	{ 0x01, 0x71, 0x09, 0x05, 0x03 }, // 7
	{ 0x36, 0x49, 0x49, 0x49, 0x36 }, // 8
	{ 0x06, 0x49, 0x49, 0x29, 0x1E }, // 9
	{ 0x00, 0x36, 0x36, 0x00, 0x00 }, // :
	{ 0x00, 0x56, 0x36, 0x00, 0x00 }, // ;
	{ 0x00, 0x08, 0x14, 0x22, 0x41 }, // <
	{ 0x14, 0x14, 0x14, 0x14, 0x14 }, // =
	{ 0x41, 0x22, 0x14, 0x08, 0x00 }, // >
	{ 0x02, 0x01, 0x51, 0x09, 0x06 }, // ?
	{ 0x32, 0x49, 0x79, 0x41, 0x3E }, // @
	{ 0x7E, 0x11, 0x11, 0x11, 0x7E }, // A
	{ 0x7F, 0x49, 0x49, 0x49, 0x36 }, // B
	{ 0x3E, 0x41, 0x41, 0x41, 0x22 }, // C
	{ 0x7F, 0x41, 0x41, 0x22, 0x1C }, // D
	{ 0x7F, 0x49, 0x49, 0x49, 0x41 }, // E
	{ 0x7F, 0x09, 0x09, 0x01, 0x01 }, // F
	{ 0x3E, 0x41, 0x41, 0x51, 0x32 }, // G
	{ 0x7F, 0x08, 0x08, 0x08, 0x7F }, // H
	{ 0x00, 0x41, 0x7F, 0x41, 0x00 }, // I
	{ 0x20, 0x40, 0x41, 0x3F, 0x01 }, // J
	{ 0x7F, 0x08, 0x14, 0x22, 0x41 }, // K
	{ 0x7F, 0x40, 0x40, 0x40, 0x40 }, // L
	{ 0x7F, 0x02, 0x04, 0x02, 0x7F }, // M
	{ 0x7F, 0x04, 0x08, 0x10, 0x7F }, // N
	{ 0x3E, 0x41, 0x41, 0x41, 0x3E }, // O
	{ 0x7F, 0x09, 0x09, 0x09, 0x06 }, // P
	{ 0x3E, 0x41, 0x51, 0x21, 0x5E }, // Q
	{ 0x7F, 0x09, 0x19, 0x29, 0x46 }, // R
	{ 0x46, 0x49, 0x49, 0x49, 0x31 }, // S
	{ 0x01, 0x01, 0x7F, 0x01, 0x01 }, // T
	{ 0x3F, 0x40, 0x40, 0x40, 0x3F }, // U
	{ 0x1F, 0x20, 0x40, 0x20, 0x1F }, // V
	{ 0x7F, 0x20, 0x18, 0x20, 0x7F }, // W
	{ 0x63, 0x14, 0x08, 0x14, 0x63 }, // X
	{ 0x03, 0x04, 0x78, 0x04, 0x03 }, // Y
	{ 0x61, 0x51, 0x49, 0x45, 0x43 }, // Z
	{ 0x00, 0x00, 0x7F, 0x41, 0x41 }, // [
	{ 0x02, 0x04, 0x08, 0x10, 0x20 }, // "\"
	{ 0x41, 0x41, 0x7F, 0x00, 0x00 }, // ]
	{ 0x04, 0x02, 0x01, 0x02, 0x04 }, // ^
	{ 0x40, 0x40, 0x40, 0x40, 0x40 }, // _
	{ 0x00, 0x01, 0x02, 0x04, 0x00 }, // `
	{ 0x20, 0x54, 0x54, 0x54, 0x78 }, // a
	{ 0x7F, 0x48, 0x44, 0x44, 0x38 }, // b
	{ 0x38, 0x44, 0x44, 0x44, 0x20 }, // c
	{ 0x38, 0x44, 0x44, 0x48, 0x7F }, // d
	{ 0x38, 0x54, 0x54, 0x54, 0x18 }, // e
	{ 0x08, 0x7E, 0x09, 0x01, 0x02 }, // f
	{ 0x08, 0x14, 0x54, 0x54, 0x3C }, // g
	{ 0x7F, 0x08, 0x04, 0x04, 0x78 }, // h
	{ 0x00, 0x44, 0x7D, 0x40, 0x00 }, // i
	{ 0x20, 0x40, 0x44, 0x3D, 0x00 }, // j
	{ 0x00, 0x7F, 0x10, 0x28, 0x44 }, // k
	{ 0x00, 0x41, 0x7F, 0x40, 0x00 }, // l
	{ 0x7C, 0x04, 0x18, 0x04, 0x78 }, // m
	{ 0x7C, 0x08, 0x04, 0x04, 0x78 }, // n
	{ 0x38, 0x44, 0x44, 0x44, 0x38 }, // o
	{ 0x7C, 0x14, 0x14, 0x14, 0x08 }, // p
	{ 0x08, 0x14, 0x14, 0x18, 0x7C }, // q
	{ 0x7C, 0x08, 0x04, 0x04, 0x08 }, // r
	{ 0x48, 0x54, 0x54, 0x54, 0x20 }, // s
	{ 0x04, 0x3F, 0x44, 0x40, 0x20 }, // t
	{ 0x3C, 0x40, 0x40, 0x20, 0x7C }, // u
	{ 0x1C, 0x20, 0x40, 0x20, 0x1C }, // v
	{ 0x3C, 0x40, 0x30, 0x40, 0x3C }, // w
	{ 0x44, 0x28, 0x10, 0x28, 0x44 }, // x
	{ 0x0C, 0x50, 0x50, 0x50, 0x3C }, // y
	{ 0x44, 0x64, 0x54, 0x4C, 0x44 }, // z
	{ 0x00, 0x08, 0x36, 0x41, 0x00 }, // '{'
	{ 0x00, 0x00, 0x7F, 0x00, 0x00 }, // |
	{ 0x00, 0x41, 0x36, 0x08, 0x00 }, // '}'
	{ 0x08, 0x08, 0x2A, 0x1C, 0x08 }, // ->
	{ 0x08, 0x1C, 0x2A, 0x08, 0x08 }, // <-
};

void delayT0()
{
	TCNT0 = 186;
	TCCR0 = 0x01;
	while ((TIFR&0x01) ==0);
	TCCR0 =0;
	TIFR =0x01 ;
}

void delayT1()
{
	TCNT1 = 0xC180;
	TCCR1A = 0x00;
	TCCR1B = 0x01;
	while ((TIFR &0x04 )==0);
	TCCR1B = 0;
	TIFR =0x04 ;
}

uint8_t xFer(uint8_t data)
{
	SPDR = data;
	while(!(SPSR & (1<<SPIF)));
	
	return SPDR;
}

void TFTSPI()
{
	DDRB |=(1<<SS);
	PORTB &= ~(1<<SS); //SS pin is low
	DDRB |=(1<<MOSI)|(1<<SCK); //MOSI pin and CLK pin as output
	SPCR |=(1<<SPE)|(1<<MSTR); //Running at master mode, 2Mhz, clkpol 0, clkphs 0
	
	
}

void writeCMD(uint8_t cmd)
{
	
	PORTD&= ~(1<<DC); //pin 1 is low
	xFer(cmd);
	PORTD|= (1<<DC); //pin 1 is high
	
}

void writeData8bit (uint8_t b)
{
	
	xFer(b);
};

uint8_t writeData16bit(uint16_t data)
{
	SPDR =(uint8_t) (data >>8);
	while (!(SPSR & (1 << SPIF)));
	SPDR =(uint8_t) data;
	while (!(SPSR & (1 << SPIF)));
	return SPDR ;
}

void hardwareReset()
{
	
	
	PORTD &=~(1<<7);
	delayT1();
	PORTD |=(1<<7);
	delayT1();
	
	
}

void InitDisplay()
{
	
	hardwareReset();
	writeCMD(SLPOUT);
	delayT1();
	
	writeCMD(COLMOD);
	writeData8bit(0x05);
	writeCMD(DISPON);
	
}


void write656Mode(uint8_t data, uint8_t count)
{
	SPDR = (data>>8);
	while (!(SPSR & (1<<SPIF)));
	SPDR = (data & 0xFF);
	while (!(SPSR & (1<<SPIF)));
	
}


void setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1)
{
	writeCMD(CASET);
	writeData8bit(0x00);
	writeData8bit(x0);
	writeData8bit(0x00);
	writeData8bit(x1);
	writeCMD(RASET);
	writeData8bit(0x00);
	writeData8bit(y0);
	writeData8bit(0x00);
	writeData8bit(y1);
}


void putCh (char ch, uint8_t x, uint8_t y, uint16_t color)
// write ch to display X,Y coordinates using ASCII 5x7 font
{
	uint16_t pixel;
	uint8_t row, col, data,bit, mask = 0x01;
	setAddrWindow(x,y,x+4,y+6);
	writeCMD(RAMWR);
	for (row=0; row<7;row++)
	{
		for (col=0; col<5;col++)
		{
			data = pgm_read_byte(&(FONT_CHARS[ch-32][col]));
			bit = data & mask;
			if (bit==0) pixel=0;
			else		pixel=color;
			writeData16bit(pixel);
			
		}
		mask <<= 1;
	}
}



void gotoXY (uint8_t x,uint8_t y)
// position cursor on character x,y grid, where 0<x<20, 0<y<19.
{
	curX = x;
	curY = y;
}
void GotoLine(uint8_t y)
// position character cursor to start of line y, where 0<y<19.
{
	curX = 0;
	curY = y;
}
void AdvanceCursor()
// moves character cursor to next position, assuming portrait orientation
{
	curX++; // advance x position
	if (curX>20) // beyond right margin?
	{
		curY++; // go to next line
		curX = 0; // at left margin
	}
	if (curY>19) // beyond bottom margin?
	curY = 0; // start at top again
}


void writeChar(char ch, uint16_t color)
// writes character to display at current cursor position.
{
	putCh(ch,curX*6, curY*8, color);
	AdvanceCursor();
}
void writeString(char *text, uint16_t color)
// writes string to display at current cursor position.
{
	for (;*text;text++) // for all non-nul chars
	writeChar(*text,color); // write the char
}

void clearScreen() // this function allows the entire display area have all black pixel
{
	uint16_t pixel;
	uint8_t row,col, x,y;
	for (row = 0; row<16;row++)
	{
		for (col = 0;col<16;col++)
		{
			setAddrWindow(row*8,col*8,8*(row+1),8*(col+1));
			writeCMD(RAMWR);
			
			for (x=0;x<8;x++)
			{
				for (y=0;y<9;y++)
				{
					pixel = 0x0000;
					writeData16bit(pixel);
				}
			}
		}
	}
}

void portraitChars()
// Writes 378 characters (5x7) to screen in portrait mode
{
	clearScreen();
	for (unsigned int i=378;i>0;i--)
	{
		uint8_t x= i % 21;
		uint8_t y= i / 21;
		char ascii = (i % 96)+32;
		putCh(ascii,x*6,y*8,BLUE);
	}
	delayT1();
}

void drawGauge(uint8_t x, uint8_t y) //This function will draw a gauge on TFT to test the steering input
{
		uint8_t j;
		uint16_t pixel;
		setAddrWindow(x,y,xMax,y+1);
		writeCMD(RAMWR);
		
		for (j=0;j<128;j++)
		{
			pixel = 0xFFFF;
			writeData16bit(pixel);
		}
		setAddrWindow(x,y+6,xMax,y+6);
		writeCMD(RAMWR);
		for (j=0;j<128;j++)
		{
			pixel = 0xFFFF;
			writeData16bit(pixel);
		}
		setAddrWindow(x,y,x,y+6);
		writeCMD(RAMWR);
		for (j=0;j<6;j++)
		{
			pixel = 0xFFFF;
			writeData16bit(pixel);
		}
		
		setAddrWindow(xMax,y,xMax,y+6);
		writeCMD(RAMWR);
		for (j=0;j<6;j++)
		{
			pixel = 0xFFFF;
			writeData16bit(pixel);
		}
	
		
		
			
}

void drawGaugeContent(uint8_t x, uint8_t y,uint8_t z)
{
	uint8_t j,k;
	uint16_t pixel;
	setAddrWindow(x,y,z,y+6);
	writeCMD(RAMWR);
	for (k=0;k<4;k++)
	{
		for (j=0;j<z/4;j++)
		{
			
			pixel = 0xFFFF;	
			writeData16bit(pixel);
		}
		
		
	}
	
	
	
}


int main ()
{
	
	DDRD |=(1<<LED)|(1<<DC); 
	DDRD|= (1<<RESET);
	PORTD |=(1<<RESET);
	
	DDRC  |=(1<<0);
	
	
	
	DDRC&=~(1<<7); //port c pin8 is input
	PORTC |=(1<<7); //enable pullup at pin8
	
	//ADC related settings
	DDRA&= ~(1<<0);
	ADCSRA = 0x87;
	ADMUX = 0x60;
	
	
	TFTSPI();
	InitDisplay();
	clearScreen();
	portraitChars();
	delayT1();
	clearScreen();
	PORTD |= (1<<LED);
	
	while(1)
	{
		ADCSRA |= (1<<ADSC);
		while((ADCSRA &(1<<ADIF))==0);
		
		uint8_t highBit = ADCH;
		//uint8_t lowBit = ADCL;
		
		//uint16_t value = (highBit<<8)|(lowBit&0xFF); 
		//uint8_t division = value/8;
		
		if ((PINC & (1<<7))==0)
		{
			
			char *str = "Key1 is pressed!"; // text to display
			
			gotoXY(0,3); // position text cursor
			writeString(str,GREEN);
		}
		
		
		else 
		{
			
			
			char *str = "Key1 is pressed!"; // text to display
			
			gotoXY(0,3); // position text cursor
			writeString(str,BLUE);
			drawGauge(0,6);
			drawGaugeContent(0,6,highBit);
			
		}	
	}
	return 0;
	
}
	
	
	
	
	
	
